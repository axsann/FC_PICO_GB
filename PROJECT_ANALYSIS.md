# FC PICO v1.00 プロジェクト分析レポート

## 1. プロジェクト概要

**プロジェクト名**: fc_pico_v100
**種別**: Raspberry Pi Pico + ファミコン連携3Dシューティングゲーム
**著作権**: Copyright (c) 2025 impact soft
**開発環境**: Arduino IDE

### 概要
本プロジェクトは、Raspberry Pi Picoをファミコン（FC）の拡張ハードウェアとして使用し、ファミコン本体と連携して3Dグラフィックスを描画するシューティングゲームです。ファミコンの6502 CPUをソフトウェアエミュレーションで実行し、その座標データを元にPico側で3D描画を行うという非常にユニークなアーキテクチャを採用しています。

---

## 2. アーキテクチャ

### システム構成
```
┌─────────────────────┐     GPIO/PIO     ┌─────────────────────┐
│   ファミコン本体     │ ◄──────────────► │  Raspberry Pi Pico   │
│  (6502 ROM実行)     │    データ通信     │  (3D描画・エミュ)    │
└─────────────────────┘                   └─────────────────────┘
                                                   │
                                                   ▼
                                          ┌─────────────────┐
                                          │   PPU出力       │
                                          │  (画面表示)     │
                                          └─────────────────┘
```

### 主要コンポーネント

| ファイル | 役割 |
|---------|------|
| `fc_pico_v100.ino` | メインスケッチ（エントリーポイント） |
| `rp_system.cpp/h` | システム心臓部：GPIO制御、DMA、FC通信 |
| `rp_fcemu.cpp/h` | 6502 CPUソフトウェアエミュレータ |
| `ap_main.cpp/h` | ゲームメインループ・状態管理 |
| `ap_game.cpp/h` | ゲーム画面処理 |
| `ArduinoGL.cpp/h` | 簡易OpenGL実装（3D描画） |
| `Canvas.cpp/h` | 2D描画ライブラリ（仮想VRAM） |
| `Obj3d.cpp/h` | 3Dオブジェクト管理 |

### 画面遷移
```
ST_INIT → ST_TITLE → ST_GAME → ST_CLEAR / ST_OVER
              │         │
              ▼         ▼
          ST_DEMO0   ST_DEMO1（デモモード）
```

---

## 3. 技術的特徴

### 3.1 6502 CPUエミュレータ
- **ベース**: FabGL プロジェクト（GPL v3ライセンス）
- **実装**: 全命令セット対応（公式命令 + 非公式命令の一部）
- **BCD演算**: 対応済み
- **特徴**: ゲームロジックをファミコン用アセンブラで記述し、Pico上でエミュレーション実行

### 3.2 PIOによる高速通信
- Raspberry Pi PicoのPIO（Programmable I/O）を活用
- 4つのステートマシン使用：
  - `SM_RECV`: データ受信
  - `SM_TRAN`: データ送信
  - `SM_BUSDIR`: バス方向制御
  - `SM_TRCNT`: 転送カウント
- DMAによる高速データ転送

### 3.3 3Dグラフィックスエンジン
- 独自実装のOpenGLサブセット（ArduinoGL）
- 対応機能：
  - 透視投影（Perspective）
  - 平行投影（Orthographic）
  - 回転・移動・スケール変換
  - バックフェイスカリング
  - 簡易ライティング
- 描画モード：
  - `GL_POLYGON`: 三角形・四角形ポリゴン
  - `GL_POINTS`: 点描画
  - `GL_SPR8/GL_SPR16`: スプライト描画

### 3.4 ダブルバッファリング
- 2面のVRAMバッファ（`vram_buf0`, `vram_buf1`）
- ちらつき防止のためのスワップ方式

---

## 4. コード品質評価

### 良い点

1. **モジュール化**: 機能ごとにファイルが分離されており、責務が明確
2. **低レベル最適化**: PIO/DMAの活用で高速通信を実現
3. **エミュレータの完成度**: 6502命令セットがほぼ完全に実装
4. **リソース管理**: 外部ツール（conv.bat）によるリソース変換パイプライン

### 改善が必要な点

1. **ライセンスの混在**
   - `rp_fcemu.cpp`: GPL v3（FabGL由来） - 商用ライセンスは作者に連絡が必要
   - `ArduinoGL.cpp`: MITライセンス（著者: Fabio de Albuquerque Dela Antonio）
   - **注意**: GPL v3コードが含まれるため、派生物全体にGPL v3が適用される可能性あり

2. **マジックナンバーの多用**
   ```cpp
   // 例: ap_game.cpp:197
   sprintf(buffer, "SCORE %02x%02x%02x%02x0  %c%02d  STAGE%02d", ...);
   ```
   定数化すると可読性向上

3. **グローバル変数の多用**
   ```cpp
   extern rp_system sys;
   extern rp_fcemu emu;
   extern ap_main ap;
   ```
   依存関係が不明確になりやすい

4. **エラーハンドリングの不足**
   ```cpp
   // rp_fcemu.cpp:66-82
   // アドレス範囲外アクセス時のエラー処理なし
   ```

5. **コメントの言語混在**
   - 日本語コメントと英語コメントが混在
   - 文字化けリスク（Shift-JIS/UTF-8）

6. **デバッグコードの残存**
   ```cpp
   // 多数の #if 0 で囲まれたデバッグコード
   // Serial.printf() による出力が残存
   ```

---

## 5. 潜在的な問題点

### 5.1 メモリ管理
```cpp
#define MAX_VERTICES 24
#define MAX_MATRICES 8
```
- 固定サイズ配列で上限チェックが甘い箇所あり
- スタックオーバーフローのリスク

### 5.2 ゼロ除算リスク
```cpp
// ArduinoGL.cpp:554-557
if ( aux.w == 0 ) {
    Serial.printf("glEnd div 0\n" );
    // return; ← コメントアウトされている
}
```
- ゼロ除算時の処理が不完全

### 5.3 未公開コンポーネント
README記載による未公開要素：
- ファミコン側ROMアセンブラソース（`$F000-$FFFF`領域）
- ゲームROM（`gamerom.c`）のアセンブラソース

これらがないと完全な改造・拡張が困難

### 5.4 ハードウェア依存
- GPIO定義がハードコード
- 特定のピン配置に依存（移植性の問題）

---

## 6. セキュリティ考慮事項

### 問題なし
- マルウェア的な動作は確認されず
- 外部通信機能なし（ローカルハードウェア連携のみ）
- ユーザーデータの収集機能なし

### 注意点
- ROM更新機能があるが、物理的なハードウェアアクセスが必要
- Watchdog Timer (WDT) による自動リセット機能あり

---

## 7. 依存ライブラリ

| ライブラリ | 用途 |
|-----------|------|
| `LittleFS` | ファイルシステム |
| `pico/stdlib.h` | Pico SDK標準ライブラリ |
| `pico/multicore.h` | デュアルコア制御 |
| `hardware/pio.h` | PIO制御 |
| `hardware/dma.h` | DMA制御 |
| `BackgroundAudio` | オーディオ出力（オプション） |
| `PWMAudio` | PWMオーディオ |
| `DFRobotDFPlayerMini` | MP3プレーヤー（オプション） |

---

## 8. 改善提案

### 優先度：高
1. **ゼロ除算の修正**: `ArduinoGL.cpp:554-557` の適切なエラーハンドリング
2. **ライセンス整理**: 使用ライブラリのライセンス明記
3. **定数化**: マジックナンバーの`#define`または`constexpr`への置換

### 優先度：中
4. **コメント言語統一**: 日本語または英語に統一
5. **デバッグコード整理**: 不要な`#if 0`ブロックの削除
6. **エラーログ強化**: 運用時のデバッグ容易性向上

### 優先度：低
7. **ドキュメント整備**: API仕様書の作成
8. **単体テスト**: エミュレータ命令のテストコード追加
9. **設定外部化**: GPIO定義の設定ファイル化

---

## 9. ファイル構成

```
fc_pico_v100/
├── fc_pico_v100.ino      # メインスケッチ
├── ap_*.cpp/h            # アプリケーション層
│   ├── ap_main.*         # メインループ
│   ├── ap_game.*         # ゲーム画面
│   ├── ap_title.*        # タイトル画面
│   ├── ap_clear.*        # クリア画面
│   ├── ap_over.*         # ゲームオーバー画面
│   └── ap_demo0.*        # デモ画面
├── rp_*.cpp/h            # Raspberry Pi Pico層
│   ├── rp_system.*       # システム制御
│   ├── rp_fcemu.*        # 6502エミュレータ
│   ├── rp_dma.*          # DMA制御
│   └── rp_debug.*        # デバッグ
├── ArduinoGL.cpp/h       # OpenGLサブセット
├── Canvas.cpp/h          # 2D描画
├── Obj3d.cpp/h           # 3Dオブジェクト
├── pio/                  # PIOアセンブラ
│   ├── fcppu.pio         # PIOソース
│   └── fcppu.pio.h       # 生成ヘッダ
└── res/                  # リソース
    ├── rom.c             # BIOS ROM
    ├── gamerom.c         # ゲームROM
    ├── *.stl             # 3Dモデル
    └── *.chr             # キャラクタデータ
```

---

## 10. ファミコンPPU機能の使用状況と制限

### 10.1 現在使用している機能

本プロジェクトはファミコンPPUの**BG（背景）機能のみ**を使用しており、スプライト機能は未使用です。

| PPU機能 | アドレス | 使用状況 |
|---------|----------|----------|
| BGパターンテーブル | - | Pico側で生成したビットマップを転送 |
| BGパレット | `$3F00-$3F1F` | 対応（`setPalData()`） |
| BGアトリビュート | `$23C0-$23FF` | 対応（`setAtrData()`） |
| **スプライトOAM** | `$2003/$2004/$4014` | **未使用** |
| **スプライトパレット** | `$3F10-$3F1F` | **未使用** |

### 10.2 描画の仕組み

```
Pico側                              ファミコン側
┌────────────────────┐              ┌────────────────────┐
│ ArduinoGL/Canvas   │              │                    │
│ ・3Dポリゴン描画    │              │    PPU             │
│ ・ソフトスプライト  │ ──DMA転送──► │  ┌──────────────┐  │
│ ・文字描画         │   (約15KB)   │  │ BG面のみ表示  │  │
│                    │              │  │ (スプライト   │  │
│ frame_buff[256×240]│              │  │  未使用)      │  │
└────────────────────┘              │  └──────────────┘  │
                                    └────────────────────┘
```

コード内の`OMD_SPR8`/`OMD_SPR16`は**Pico側のソフトウェア描画**であり、ファミコンのハードウェアスプライトではありません。すべてBGビットマップに変換されて送られます。

### 10.3 色数の制限（4色問題）

#### 変換処理の実装 (`rp_system.cpp:261-268`)

```cpp
const uint16_t conv_tbl[4] = {
    0x0000,  // 色0
    0x0001,  // 色1
    0x0100,  // 色2
    0x0101,  // 色3
};
...
dt |= conv_tbl[ frame_buff[ fidx++ ] & 3 ];  // 2ビットマスク = 4色のみ
```

#### 本来のファミコンとの比較

| 項目 | 本来のファミコン | FC PICO |
|------|-----------------|---------|
| BGパレット | 4パレット × 4色 = 16色 | **1パレット × 4色 = 4色** |
| アトリビュート | 16×16px単位でパレット切替 | コード存在するが未活用 |
| スプライト | 4パレット × 4色 = 16色 | **未使用** |
| 同時発色数 | 最大25色程度 | **4色のみ** |

#### 擬似階調表現

4色の制限を補うため、ディザリングで擬似的な濃淡を表現しています。

```cpp
// Canvas.cpp:36-55
const uint16_t DitherTbl[] = {
    0b1111111111111111,  // 0 (最も明るい)
    0b1111111111111110,  // 1
    ...
    0b0001000000000000,  // 15 (最も暗い)
};
```

4色 × ディザ16段階で擬似的な階調表現を実現しています。

### 10.4 BGアトリビュート拡張の限界

仮にBGのパレット切替を実装しても、根本的な問題があります。

#### タイル境界の制約

```
ファミコンBGのアトリビュート構造:

┌────────┬────────┐
│ 16x16  │ 16x16  │  ← アトリビュート1単位 = 16×16ピクセル
│ PAL:0  │ PAL:1  │
├────────┼────────┤
│ 16x16  │ 16x16  │
│ PAL:2  │ PAL:0  │
└────────┴────────┘
```

#### 問題のシナリオ

```
自機（青:PAL0）が移動して敵（赤:PAL1）のタイル領域に入ると...

移動前:                    移動後:
┌────────┬────────┐        ┌────────┬────────┐
│        │ 敵(赤) │        │   敵と自機が    │
│ 自機   │ PAL:1  │   →   │   同じタイル内  │
│ (青)   │        │        │   PAL:1 or 0?  │
│ PAL:0  │        │        │   → 片方の色に │
└────────┴────────┘        └────────┴────────┘
```

BGのパレットはタイル単位でしか変更できないため、自由に動くゲームオブジェクトには実質的に意味がありません。

#### 本来のスプライトなら

```
スプライト = オブジェクト単位でパレット保持

┌───────────────────────────────┐
│      背景 (BG)                │
│   ┌───┐                       │
│   │敵 │ ← スプライト PAL:1    │
│   └───┘                       │
│        ┌───┐                  │
│        │自機│ ← スプライト PAL:0
│        └───┘                  │
└───────────────────────────────┘

→ どこに移動しても各キャラの色は独立
```

---

## 11. スプライト機能追加の実現可能性

### 11.1 必要な変更箇所

#### Pico側（実装可能）

```cpp
// 新規追加が必要な関数例
bool rp_system::setOAM(uint8_t idx, uint8_t y, uint8_t tile,
                        uint8_t attr, uint8_t x) {
    m_OAM[idx * 4 + 0] = y;      // Y座標
    m_OAM[idx * 4 + 1] = tile;   // タイル番号
    m_OAM[idx * 4 + 2] = attr;   // 属性（パレット、反転等）
    m_OAM[idx * 4 + 3] = x;      // X座標
    m_OAM_CHG = true;
    return true;
}

// データモードで送信
void rp_system::sendOAMData() {
    drq_ret(PF_DAT_RAM, 0x0200, 0x100);  // OAMデータを$0200に転送
}
```

#### ファミコン側（問題あり）

```asm
; VBlank(NMI)ハンドラ内で必要な処理
NMI_Handler:
    LDA #$02        ; OAMデータは$0200から
    STA $4014       ; OAM DMA開始（256バイト転送）
    ; Picoからのデータ受信処理...
    RTI
```

### 11.2 実現の障壁

| 項目 | 状態 | 難易度 |
|------|------|--------|
| Pico側コマンド追加 | ソース公開済 | **低** |
| OAMバッファ管理 | 新規実装 | **低** |
| FC側NMI処理追加 | **ソース非公開** | **高** |
| CHRパターン追加 | 要ROM改造 | 中 |
| タイミング調整 | VBlank制約 | 中 |

### 11.3 最大の問題：ファミコン側ROMの非公開

`readme_jp.txt`より:
> 更新用のファミコンROMのアセンブラソース一式は、まだ未整理の為　現状は**非公開**

ファミコン側の6502プログラムを改造できないと、OAM DMA（`$4014`への書き込み）を追加できません。

### 11.4 代替案

| 案 | 内容 | 実現性 |
|----|------|--------|
| A. ROM公開を待つ | 作者が将来公開予定と記載 | 待ち |
| B. 独自ROMを作成 | `$F000-$FFFF`以外は更新可能なので、NMI/OAM処理を含む独自6502プログラムを作成 | 高難度 |
| C. 画面分割方式 | 画面上部:BGのみ（UI）、画面下部:BG+スプライト併用 | 中難度 |

### 11.5 結論

**技術的には可能だが、ファミコン側ROMソースが非公開のため現状では困難。**

作者にコンタクトしてソース公開を依頼するか、NMI処理を含む独自の6502プログラムを一から書く必要があります。

---

## 12. 総評

本プロジェクトは、ファミコンとRaspberry Pi Picoを連携させた非常にユニークで技術的に興味深いプロジェクトです。6502エミュレータ、3Dグラフィックスエンジン、PIO通信という複数の高度な技術を組み合わせており、組込みシステム開発とレトロゲーム開発の知識が融合しています。

コード品質は全体的に良好ですが、商用利用やオープンソース公開を検討する場合は、ライセンスの整理とドキュメント整備が必要です。また、一部のエラーハンドリング改善により、より堅牢なシステムになるでしょう。

**技術レベル**: ★★★★☆（上級者向け）
**完成度**: ★★★★☆（ゲームとして動作可能）
**拡張性**: ★★★☆☆（未公開ソースがあるため制限あり）
**ドキュメント**: ★★☆☆☆（改善の余地あり）
